<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuliaobored.github.io</id>
    <title>Cetacean</title>
    <updated>2022-01-19T14:00:03.851Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuliaobored.github.io"/>
    <link rel="self" href="https://wuliaobored.github.io/atom.xml"/>
    <subtitle>网站测试中*</subtitle>
    <logo>https://wuliaobored.github.io/images/avatar.png</logo>
    <icon>https://wuliaobored.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Cetacean</rights>
    <entry>
        <title type="html"><![CDATA[平面最近点对]]></title>
        <id>https://wuliaobored.github.io/post/nearest_points/</id>
        <link href="https://wuliaobored.github.io/post/nearest_points/">
        </link>
        <updated>2022-01-19T13:44:15.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="代码">代码</h2>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
struct Point { int x, y; };
typedef vector&lt;Point&gt;::iterator itp;	//指针类型，用于遍历vector函数
typedef vector&lt;Point&gt; vec;
bool cmpx(const Point a, const Point b) { return a.x &lt; b.x; }	//比较两点的X坐标大小
bool cmpy(const Point a, const Point b) { return a.y &lt; b.y; }	//比较两点的Y坐标大小
double distance(const Point a, const Point b) { return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)); }	//计算两点间距离
vec p;
double ans = 1e18;
void Solve(itp l, itp r, double&amp; d) {
	if (r - l &lt;= 1)	return;				//当区间长度小于等于1时返回
	vec Q;
	itp mid = l + (r - l) / 2;			//分治思想，将区间拆分为两个小区间计算
	double w = mid-&gt;x;					//w为大区间中点对应点的x坐标
	Solve(l, mid, d);					//计算区间[l, mid)中距离最小值
	Solve(mid, r, d);					//计算区间[mid, r)中距离最小值
	inplace_merge(l, mid, r, cmpy);		//使用merge函数将区间按y轴从小到大合并
	for (itp x = l; x != r; x++)		
		if (abs(w - x-&gt;x) &lt;= d)			//将此时到垂直于x轴中的直线的距离小于此时最小距离d的点放入Q待处理
			Q.push_back(*x);
	for (itp x = Q.begin(), y = x; x != Q.end(); x++) {	//遍历Q，对于Q中每一个点x
		while (y != Q.end() &amp;&amp; y-&gt;y &lt;= x-&gt;y + d)		//找出到此点x的距离小于最小距离d的个数y
			y++;						 
		for (itp z = x + 1; z != y; z++)				//计算从点x后面一个点开始y个点到点x的距离
			d = min(d, distance(*x, *z));				//更新最小距离
	}
}
int main() {
	int n, x, y;
	Point tmp;
	cin.tie(0), cout.tie(0);
	std::ios::sync_with_stdio(false);
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; x &gt;&gt; y;
		tmp.x = x, tmp.y = y;
		p.push_back(tmp);
	}
	sort(p.begin(), p.end(), cmpx);
	Solve(p.begin(), p.end(), ans);
	printf(&quot;%.0lf\n&quot;, ans*ans);
	return 0;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="代码">代码</h2>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
struct Point { int x, y; };
typedef vector&lt;Point&gt;::iterator itp;	//指针类型，用于遍历vector函数
typedef vector&lt;Point&gt; vec;
bool cmpx(const Point a, const Point b) { return a.x &lt; b.x; }	//比较两点的X坐标大小
bool cmpy(const Point a, const Point b) { return a.y &lt; b.y; }	//比较两点的Y坐标大小
double distance(const Point a, const Point b) { return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)); }	//计算两点间距离
vec p;
double ans = 1e18;
void Solve(itp l, itp r, double&amp; d) {
	if (r - l &lt;= 1)	return;				//当区间长度小于等于1时返回
	vec Q;
	itp mid = l + (r - l) / 2;			//分治思想，将区间拆分为两个小区间计算
	double w = mid-&gt;x;					//w为大区间中点对应点的x坐标
	Solve(l, mid, d);					//计算区间[l, mid)中距离最小值
	Solve(mid, r, d);					//计算区间[mid, r)中距离最小值
	inplace_merge(l, mid, r, cmpy);		//使用merge函数将区间按y轴从小到大合并
	for (itp x = l; x != r; x++)		
		if (abs(w - x-&gt;x) &lt;= d)			//将此时到垂直于x轴中的直线的距离小于此时最小距离d的点放入Q待处理
			Q.push_back(*x);
	for (itp x = Q.begin(), y = x; x != Q.end(); x++) {	//遍历Q，对于Q中每一个点x
		while (y != Q.end() &amp;&amp; y-&gt;y &lt;= x-&gt;y + d)		//找出到此点x的距离小于最小距离d的个数y
			y++;						 
		for (itp z = x + 1; z != y; z++)				//计算从点x后面一个点开始y个点到点x的距离
			d = min(d, distance(*x, *z));				//更新最小距离
	}
}
int main() {
	int n, x, y;
	Point tmp;
	cin.tie(0), cout.tie(0);
	std::ios::sync_with_stdio(false);
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; x &gt;&gt; y;
		tmp.x = x, tmp.y = y;
		p.push_back(tmp);
	}
	sort(p.begin(), p.end(), cmpx);
	Solve(p.begin(), p.end(), ans);
	printf(&quot;%.0lf\n&quot;, ans*ans);
	return 0;
}
</code></pre>
<!-- more -->
<h2 id="习题luogu-p7883"><a href="https://www.luogu.com.cn/problem/P7883">习题:Luogu P7883</a></h2>
<h2 id="参考文章"><a href="https://www.luogu.com.cn/blog/over-knee-socks/solution-p7883">参考文章</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sparse Table]]></title>
        <id>https://wuliaobored.github.io/post/sparse_table/</id>
        <link href="https://wuliaobored.github.io/post/sparse_table/">
        </link>
        <updated>2022-01-17T14:02:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="作用">作用</h2>
<p>ST算法，通过倍增的思想较快求解RMQ(区间最值)问题</p>
<h2 id="思路">思路</h2>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i, j]=max[i, i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，则可以通过递推求解每个具有代表性的区间的最值，这些区间的右端点为左端点加上2的整数次幂减去1<br>
递推时用到了倍增的思想，即子区间长度成倍增长。有公式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">F[i, j] = max(F[i, j-1], F[i+2^{j-1}, j-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，即将长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>的子区间拆为两个长度皆为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的子区间取最大值<br>
询问时</p>
<h2 id="代码">代码</h2>
<pre><code class="language-C++">void ST_prework() {
	for (int i = 1; i &lt;= N; i++)
		f[i][0] = a[i];
	int t = log2(N) + 1;
	for (int j = 1; j &lt; t; j++)
		for (int i = 1; i &lt;= N - (1 &lt;&lt; j) + 1; i++)
			f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);
}
int ST_query(int l, int r) {
	int k = log2(r - l + 1);
	return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="作用">作用</h2>
<p>ST算法，通过倍增的思想较快求解RMQ(区间最值)问题</p>
<h2 id="思路">思路</h2>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">F[i, j]=max[i, i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，则可以通过递推求解每个具有代表性的区间的最值，这些区间的右端点为左端点加上2的整数次幂减去1<br>
递推时用到了倍增的思想，即子区间长度成倍增长。有公式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>F</mi><mo>[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">F[i, j] = max(F[i, j-1], F[i+2^{j-1}, j-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，即将长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>的子区间拆为两个长度皆为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的子区间取最大值<br>
询问时</p>
<h2 id="代码">代码</h2>
<pre><code class="language-C++">void ST_prework() {
	for (int i = 1; i &lt;= N; i++)
		f[i][0] = a[i];
	int t = log2(N) + 1;
	for (int j = 1; j &lt; t; j++)
		for (int i = 1; i &lt;= N - (1 &lt;&lt; j) + 1; i++)
			f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);
}
int ST_query(int l, int r) {
	int k = log2(r - l + 1);
	return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);
}
</code></pre>
<!-- more -->
<h2 id="习题">习题</h2>
<p><a href="https://www.luogu.com.cn/problem/P3865">Luogu P3865 ST表</a><br>
<a href="https://www.luogu.com.cn/problem/P7333">Luogu P7333 JFCA</a><br>
<a href="https://www.luogu.com.cn/problem/P7809">Luogu P7809 01序列</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP]]></title>
        <id>https://wuliaobored.github.io/post/kmp/</id>
        <link href="https://wuliaobored.github.io/post/kmp/">
        </link>
        <updated>2022-01-14T12:30:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="作用">作用</h2>
<p>KMP算法，又称模式匹配算法，用于快速求出字符串A在字符串B中各次出现的位置，于Knuth、Pratt和Morris三人在1977年共同发布</p>
<h2 id="思路">思路</h2>
<p>匹配两个字符串时，朴素算法为遍历字符串B每一位，同时遍历字符串A检查是否与B匹配，匹配失败跳转B的下一位，并重新开始匹配<br>
KMP算法就是对匹配失败时的跳转进行了优化。匹配失败时如果此时已匹配好的字符串A子串的后缀与其前缀相等，那么就无需从已经匹配好的B的子串第一位的下一位，而可以一次性跳转到<strong>已经匹配好的B的子串第一位后面等值于A子串此时前后缀相等位数</strong>。由此可知，我们需要对字符串A进行预处理，求得字符串A从头开始每个子串的最大公共真前后缀(不包括A本身的前后缀)，再将A与B进行匹配，失败时跳转此时A最大公共前后缀长度</p>
<h3 id="做法">做法</h3>
<ol>
<li>对字符串A进行自我匹配，求出最大公共真前后缀：<br>
对字符串A进行遍历，对于第i位，求出字符串A第1位到第i位的子串的真前缀与真后缀所能匹配的最大长度，即<strong>最大公共真前后缀的长度</strong>，记录为数组<code>next[i]</code></li>
<li>对字符串B与字符串A进行匹配：<br>
对字符串B进行遍历，从字符串B第1位开始与字符串A第j+1位进行匹配，若匹配成功则对两个字符串下一位进行匹配，若匹配失败则<strong>字符串B第i位与字符串A第next[j]位开始匹配</strong>，仍然匹配失败则与字符串A第<code>next[next[j]]</code>位进行匹配，以此类推，直至匹配成功继续对两字符串下一位进行匹配，每当完全匹配字符串A与B时用数组记录下此刻位置</li>
</ol>
<h3 id="求解next数组">求解next数组</h3>
<p>数组next[i]表示此时字符串A第一位到第i位子串的最大公共前后缀长度<br>
假设现在我们已经求出了<code>next[i-1]</code>，需要求<code>next[i]</code>：<br>
于是我们在已经匹配完毕的子串末尾新加了一个字符<code>a[i]</code>，则此时需判断<code>a[i]</code>是否能与<code>a[j+1]</code>匹配<br>
若匹配失败，则与<code>a[next[(j+1)-1]]</code>进行匹配，即<code>next[i] = next[j]</code><br>
若匹配成功，则<code>next[i] = next[i-1] + 1</code></p>
<h2 id="代码">代码</h2>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
const int SIZE = 1e6 + 10;
char a[SIZE], b[SIZE];		//目标是从字符串B中找字符串A的位置
int n, m;
int Next[SIZE];				//Next[i]储存字符串A前i位的最大公共真前后缀的长度
int main() {
	cin &gt;&gt; n &gt;&gt; a + 1 &gt;&gt; m &gt;&gt; b + 1;	//字符串下标从1开始
	for (int i = 2, j = 0; i &lt;= n; i++) {
		while (j &gt; 0 &amp;&amp; a[i] != a[j + 1])	j = Next[j];	//将j赋值位Next[j]直到下一位匹配成功或j = 0(即重头开始匹配)
		if (a[i] == a[j + 1])	j++;						//当下一位匹配成功时将j+1以匹配下一位
		Next[i] = j;										//储存此时最大真前后缀的值
	}
	for (int i = 1, j = 0; i &lt;= m; i++) {
		while (j &gt; 0 &amp;&amp; b[i] != a[j + 1])	j = Next[j];	//思路同上，只不过上面为A自己匹配，这次为A与B相匹配
		if (b[i] == a[j + 1])	j++;
		if (j == n) {		//完全匹配成功
			cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;
		}
	}	
	return 0;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="作用">作用</h2>
<p>KMP算法，又称模式匹配算法，用于快速求出字符串A在字符串B中各次出现的位置，于Knuth、Pratt和Morris三人在1977年共同发布</p>
<h2 id="思路">思路</h2>
<p>匹配两个字符串时，朴素算法为遍历字符串B每一位，同时遍历字符串A检查是否与B匹配，匹配失败跳转B的下一位，并重新开始匹配<br>
KMP算法就是对匹配失败时的跳转进行了优化。匹配失败时如果此时已匹配好的字符串A子串的后缀与其前缀相等，那么就无需从已经匹配好的B的子串第一位的下一位，而可以一次性跳转到<strong>已经匹配好的B的子串第一位后面等值于A子串此时前后缀相等位数</strong>。由此可知，我们需要对字符串A进行预处理，求得字符串A从头开始每个子串的最大公共真前后缀(不包括A本身的前后缀)，再将A与B进行匹配，失败时跳转此时A最大公共前后缀长度</p>
<h3 id="做法">做法</h3>
<ol>
<li>对字符串A进行自我匹配，求出最大公共真前后缀：<br>
对字符串A进行遍历，对于第i位，求出字符串A第1位到第i位的子串的真前缀与真后缀所能匹配的最大长度，即<strong>最大公共真前后缀的长度</strong>，记录为数组<code>next[i]</code></li>
<li>对字符串B与字符串A进行匹配：<br>
对字符串B进行遍历，从字符串B第1位开始与字符串A第j+1位进行匹配，若匹配成功则对两个字符串下一位进行匹配，若匹配失败则<strong>字符串B第i位与字符串A第next[j]位开始匹配</strong>，仍然匹配失败则与字符串A第<code>next[next[j]]</code>位进行匹配，以此类推，直至匹配成功继续对两字符串下一位进行匹配，每当完全匹配字符串A与B时用数组记录下此刻位置</li>
</ol>
<h3 id="求解next数组">求解next数组</h3>
<p>数组next[i]表示此时字符串A第一位到第i位子串的最大公共前后缀长度<br>
假设现在我们已经求出了<code>next[i-1]</code>，需要求<code>next[i]</code>：<br>
于是我们在已经匹配完毕的子串末尾新加了一个字符<code>a[i]</code>，则此时需判断<code>a[i]</code>是否能与<code>a[j+1]</code>匹配<br>
若匹配失败，则与<code>a[next[(j+1)-1]]</code>进行匹配，即<code>next[i] = next[j]</code><br>
若匹配成功，则<code>next[i] = next[i-1] + 1</code></p>
<h2 id="代码">代码</h2>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
const int SIZE = 1e6 + 10;
char a[SIZE], b[SIZE];		//目标是从字符串B中找字符串A的位置
int n, m;
int Next[SIZE];				//Next[i]储存字符串A前i位的最大公共真前后缀的长度
int main() {
	cin &gt;&gt; n &gt;&gt; a + 1 &gt;&gt; m &gt;&gt; b + 1;	//字符串下标从1开始
	for (int i = 2, j = 0; i &lt;= n; i++) {
		while (j &gt; 0 &amp;&amp; a[i] != a[j + 1])	j = Next[j];	//将j赋值位Next[j]直到下一位匹配成功或j = 0(即重头开始匹配)
		if (a[i] == a[j + 1])	j++;						//当下一位匹配成功时将j+1以匹配下一位
		Next[i] = j;										//储存此时最大真前后缀的值
	}
	for (int i = 1, j = 0; i &lt;= m; i++) {
		while (j &gt; 0 &amp;&amp; b[i] != a[j + 1])	j = Next[j];	//思路同上，只不过上面为A自己匹配，这次为A与B相匹配
		if (b[i] == a[j + 1])	j++;
		if (j == n) {		//完全匹配成功
			cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;
		}
	}	
	return 0;
}
</code></pre>
<!-- more -->
<h2 id="推荐文章">推荐文章</h2>
<p><a href="https://oi-wiki.org/string/kmp/">OI-WIKI: KMP</a><br>
<a href="https://www.cnblogs.com/lijingran/p/8619711.html">博客园lijingran：KMP</a><br>
<a href="https://www.cnblogs.com/dusf/p/kmp.html">博客园sofu6: KMP</a></p>
<h2 id="习题">习题</h2>
<p><a href="https://www.luogu.com.cn/problem/P1709">P1709 Hidden Password</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[位运算]]></title>
        <id>https://wuliaobored.github.io/post/bitwise/</id>
        <link href="https://wuliaobored.github.io/post/bitwise/">
        </link>
        <updated>2022-01-13T01:46:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="相关概念">相关概念</h1>
<h2 id="机器数与真值">机器数与真值</h2>
<ul>
<li>机器数：<br>
<strong>一个数在计算机中二进制的表示形式</strong>，<br>
机器数第一位用来存放符号，正数为0，负数为1</li>
<li>真值：<br>
<strong>机器数对应的真正数值</strong></li>
</ul>
<h2 id="原码反码与补码">原码，反码与补码</h2>
<ul>
<li>原码：<br>
<strong>符号位加上真值的绝对值</strong></li>
<li>反码:<br>
<strong>正数的反码是其本身</strong><br>
<strong>负数的反码是在其原码基础上符号位不变，其余位取反</strong></li>
<li>补码:<br>
<strong>正数的补码是其本身</strong><br>
<strong>负数的补码是其反码+1</strong></li>
</ul>
<h2 id="位运算">位运算</h2>
<ul>
<li>与<code>&amp;</code>：两个位都为1时，结果才为1</li>
<li>或<code>|</code>：两个位只有有1，结果就位1</li>
<li>异或<code>^</code>：两个位相同时结果为0，相异时为1</li>
<li>取反<code>~</code>：1变0，0变1</li>
<li>左移<code>&lt;&lt;</code>：各二进制位同时向左移动，高位丢弃，低位补0<br>
1 &lt;&lt; n = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>;  n  &lt;&lt; 1 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span></li>
<li>算术右移<code>&gt;&gt;</code>：各二进制位同时向右移动，低位丢弃，高位补符号位（一般编译器）<br>
n &gt;&gt; 1 = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mi>n</mi><mn>2.0</mn></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac{n}{2.0} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">.</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></li>
<li>逻辑右移<code>&gt;&gt;</code>：各二进制位同时向右移动，低位丢弃，高位补0</li>
</ul>
<h1 id="算法">算法</h1>
<h2 id="快速幂">快速幂</h2>
<p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup><mo>≡</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">a^b\equiv p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></p>
<h3 id="思路">思路：</h3>
<p>将b拆为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mi>k</mi><mn>1</mn></msub></msup><mo>+</mo><msup><mn>2</mn><msub><mi>k</mi><mn>2</mn></msub></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mi>x</mi><msub><mi>k</mi><mi>n</mi></msub></msup></mrow><annotation encoding="application/x-tex">2^{k_1} + 2^{k_2} + ... + x^{k_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，即将b个a相乘拆为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><msup><mn>2</mn><msub><mi>k</mi><mn>1</mn></msub></msup><mo>+</mo><mi>a</mi><mo>∗</mo><msup><mn>2</mn><msub><mi>k</mi><mn>2</mn></msub></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>a</mi><mo>∗</mo><msup><mi>x</mi><msub><mi>k</mi><mi>n</mi></msub></msup></mrow><annotation encoding="application/x-tex">a*2^{k_1} + a*2^{k_2} + ... + a*x^{k_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br>
先预处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mi>n</mi></msup></msup></mrow><annotation encoding="application/x-tex">a^{2^n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.87998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.87998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>的值，再把b用二进制表示，循环b二进制位数次，每次第0位为1时将答案与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><msup><mn>2</mn><mi>i</mi></msup></msup></mrow><annotation encoding="application/x-tex">a^{2^i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944599999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944599999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9020857142857143em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>相乘<br>
此种思路同样可以计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p>
<h3 id="模板">模板：</h3>
<pre><code class="language-C++">long long quick_pow(int a, int b, int p) {
	int ans = 1 % p;
	while (b) {
		if (b &amp; 1)
			ans = (long long)ans * a % p;
		a = (long long)a * a % p;
		b &gt;&gt;= 1;
	}
	return ans;
}
</code></pre>
<h2 id="二进制状态压缩">二进制状态压缩</h2>
<p>用一个二进制整数表示bool数组</p>
<h3 id="实现">实现：</h3>
<ul>
<li>取出整数在二进制表示下的第k位  <code>(n &gt;&gt; k) &amp; 1</code></li>
<li>取出整数在二进制表示下的第0~k-1位  <code>n &amp; ((1 &lt;&lt; k) - 1)</code></li>
<li>将整数在二进制表示下的第k位取反  <code>n ^ (1 &lt;&lt; k)</code></li>
<li>对整数在二进制表示下的第k位赋值为1  <code>n | (1 &lt;&lt; k)</code></li>
<li>对整数在二进制表示下的第k位赋值为0  <code>n &amp; (~(1 &lt;&lt; k))</code></li>
</ul>
<h2 id="成对变换">成对变换</h2>
<h2 id="lowbit-运算">lowbit 运算</h2>
<h2 id="推荐文章">推荐文章</h2>
<p><a href="https://www.cnblogs.com/wqbin/p/11142873.html">原码，反码与补码</a><br>
<a href="https://www.runoob.com/w3cnote/bit-operation.html">位运算</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散化]]></title>
        <id>https://wuliaobored.github.io/post/discrete/</id>
        <link href="https://wuliaobored.github.io/post/discrete/">
        </link>
        <updated>2022-01-13T00:47:45.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="概念">概念</h1>
<p>将无穷大集合中若干元素映射为有限集合以便于统计，常用于元素范围过大致使数组放不下而元素个数很少的情况，注意使用条件需要<strong>满足问题与数值的绝对大小无关</strong></p>
<h1 id="思路">思路</h1>
<p>将数据通过<code>sort()</code>排序后借助<code>unique()</code>删去重复元素<br>
使用<code>lower_bound()</code>查找元素<strong>x</strong>在离散化数组中的下标</p>
<h1 id="代码实现">代码实现</h1>
<pre><code class="language-C++">void discrete() {	//离散化
	sort(a, a + n);
	t = unique(a, a + n) - a;
	for (int i = 0; i &lt; t; i++) 
		b[i] = a[i];
}
int query(int x) {	//查询
	return lower_bound(b, b + t, x) - b;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="概念">概念</h1>
<p>将无穷大集合中若干元素映射为有限集合以便于统计，常用于元素范围过大致使数组放不下而元素个数很少的情况，注意使用条件需要<strong>满足问题与数值的绝对大小无关</strong></p>
<h1 id="思路">思路</h1>
<p>将数据通过<code>sort()</code>排序后借助<code>unique()</code>删去重复元素<br>
使用<code>lower_bound()</code>查找元素<strong>x</strong>在离散化数组中的下标</p>
<h1 id="代码实现">代码实现</h1>
<pre><code class="language-C++">void discrete() {	//离散化
	sort(a, a + n);
	t = unique(a, a + n) - a;
	for (int i = 0; i &lt; t; i++) 
		b[i] = a[i];
}
int query(int x) {	//查询
	return lower_bound(b, b + t, x) - b;
}
</code></pre>
<!-- more -->
<h2 id="习题">习题</h2>
<p><a href="https://www.acwing.com/problem/content/description/105/">AcWing103 电影</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Test*]]></title>
        <id>https://wuliaobored.github.io/post/test/</id>
        <link href="https://wuliaobored.github.io/post/test/">
        </link>
        <updated>2021-11-13T02:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天创建了自己的个人博客ヾ(≧▽≦*)o</p>
]]></content>
    </entry>
</feed>